#lang racket
(require "ast.rkt"
         "dependencies.rkt"
         "descriptors.rkt"
         racket/stxparam)

(provide all-descriptors
         current-scope
         (struct-out exn:fail:compile)
         compile-ast
         compile-root
         with-clean-compile)


(define-struct (exn:fail:compile exn:fail:read) ())

(define (raise-compile-error loc msg . fmts)
  (raise (make-exn:fail:compile
          (apply format (cons msg fmts))
          (current-continuation-marks)
          (list loc loc))))

;; append a name onto another, e.g.
;;   (name-append "a.b" "c") = "a.b.c"
;;   (name-append "" "d.e") = "d.e"
(define (name-append pre post)
  (if (equal? pre "")
      post
      (string-append pre "." post)))

;; break scope into subscopes, e.g.
;;   (subscopes "a.b.c") = '("a.b.c" "a.b" "a")
(define (subscopes scope)
  (define-values (_ scopes)
    (for/fold ([fullname ""] [scopes '()])
              ([part (in-list (string-split scope "."))])
      (let ([new-fullname (name-append fullname part)])
        (values new-fullname
                (cons new-fullname scopes)))))
  scopes)


;; maps qualified names to descriptors
;; e.g. [file 'descriptor.proto']
;;     syntax = 'proto3';
;;     package google.protobuf;
;;     message Field {
;;       enum Type { UINT32 = 0; ... }
;;       Type type = 1;
;;     }
;; would be generated into
;;   google                        =>  <file-descriptor% 'descriptor.proto'>
;;   google.protobuf               =>  <file-descriptor% 'descriptor.proto'>
;;   google.protobuf.Field         =>  <descriptor% 'Field'>
;;   google.protobuf.Field.Type    =>  <enum-descriptor% 'Type'>
;;   google.protobuf.Field.UINT32  =>  <enum-value% 'UINT32'>
;;   google.protobuf.Field.type    =>  <field-descriptor% 'Type'>
(define all-descriptors (make-parameter (make-hash)))

;; check that the descriptor (any kind) is not already used.
;; if it's used, raises a compile error
;; if it isn't, then adds it to all-descriptors
;; add-descriptor : object% string? srcloc? -> void
(define (add-descriptor des full-name loc)
  (cond
    [(hash-ref (all-descriptors) full-name #f)
     =>
     (λ (used-des)
       (let ([fd (if (is-a? used-des file-descriptor%)
                     used-des
                     (send used-des get-file-descriptor))])
         (raise-compile-error loc
                              "name ~v already bound in file ~v"
                              full-name
                              (path->string
                               (find-relative-path (current-directory)
                                                   (send fd get-file-path))))))]

    [else
     (hash-set! (all-descriptors) full-name des)]))




;; below is a macro for generating compile-ast function, so that it is
;; less tedious
;; for instance #:sub-asts a => m
;; automates a loop that iterates over 'a' and uses the method 'm' on
;; the current descriptor, to get a target for the ast
;; erm, as in:
;;   #:sub-asts fields => add-field
;; becomes
;;   (for ([field-ast (in-list fields)])
;;     (compile-ast field-ast (send this-descriptor add-field (ast-name field-ast))))

;; the current ast node being parsed
(define-syntax-parameter this-ast
  (λ (stx) (error "use of this-ast outside of ast compiler")))
;; the loc of that node
(define-syntax-parameter this-loc
  (λ (stx) (error "use of this-loc outside of ast compiler")))
;; the descriptor being parsed into
(define-syntax-parameter this-desc
  (λ (stx) (error "use of this-desc outside of ast compiler")))
;; sub-ast in loop generated by #:sub-asts
(define-syntax-parameter this-sub-ast
  (λ (stx) (error "use of this-ast outside of ast compiler")))

(begin-for-syntax
  (require racket/base
           racket/syntax
           syntax/parse)

  (define-splicing-syntax-class astc-kw-clause
    #:attributes ([params 1] [pre-stmts 1] [stmts 1])
    #:datum-literals (=>)

    (pattern (~seq #:scoped-name e)
             #:with [pre-stmts ...]
             #'[(add-descriptor this-desc
                                (name-append (current-scope) e)
                                loc)]
             #:with [params ...] #'[]
             #:with [stmts ...] #'[])

    (pattern (~seq #:param [P v])
             #:with [params ...] #'[[P v]]
             #:with [stmts ...] #'[]
             #:with [pre-stmts ...] #'[])

    (pattern (~seq #:sub-asts e => method:id)
             #:with [stmts ...] #'[(for ([the-sub-ast (in-list e)])
                                     (compile-ast the-sub-ast
                                                  (send this-desc method (ast-name the-sub-ast))))]
             #:with [pre-stmts ...] #'[]
             #:with [params ...] #'[])

    (pattern (~seq #:sub-asts e => [method ...])
             #:with [stmts ...]
             #'[(for ([the-sub-ast (in-list e)])
                  (syntax-parameterize ([this-sub-ast (make-rename-transformer #'the-sub-ast)])
                    (compile-ast the-sub-ast (send this-desc method ...))))]
             #:with [pre-stmts ...] #'[]
             #:with [params ...] #'[])))


(define-syntax gen-ast-compiler
  (syntax-parser
    [(_ [(struct-id:id (field-pat ...))
         kwc:astc-kw-clause ...
         other:expr ...] ...)
     #'(λ (the-ast the-desc)
         (syntax-parameterize ([this-ast (make-rename-transformer #'the-ast)]
                               [this-desc (make-rename-transformer #'the-desc)])
           (match the-ast
             [(struct struct-id (loc field-pat ...))
              (syntax-parameterize ([this-loc (make-rename-transformer #'loc)])
                kwc.pre-stmts ... ...
                (parameterize (kwc.params ... ...)
                  kwc.stmts ... ...
                  other ...))]
             ...
             [_ (displayln this-ast) (error "unimplement AST")])))]))



;; the current scope string (e.g. "google.protobuf" or "")
(define current-scope (make-parameter ""))

;; the current outer message, for when compiling a field or sub-message
;; of a message
(define current-message (make-parameter #f))

;; info about types that need to be resolved
(define current-unresolved
  (make-parameter '()))

(struct unresolved-field-type (ast desc scope))
(define (add-unresolved-field ast desc)
  (current-unresolved (cons (unresolved-field-type ast
                                                   desc
                                                   (current-scope))
                            (current-unresolved))))


;; compile an ast into the given descriptor.
;; this adds the necessary properties to the
;; *-descriptor% object.
;;
;; compile-ast : ast? object% -> void
(define compile-ast
  (gen-ast-compiler

   [(ast:message (name fields oneofs map-fields messages enums res opts))
    #:scoped-name name
    #:param [current-message this-desc]
    #:param [current-scope (name-append (current-scope) name)]
    #:sub-asts fields => add-field
    #:sub-asts messages => add-nested-type
    #:sub-asts enums => add-nested-enum
    #:sub-asts oneofs => add-oneof
    ;; TODO: compile message options
    (send this-desc set-full-name (current-scope))]


   [(ast:field (name number label type opts))
    #:scoped-name name
    ;; TODO: compile field options
    (send this-desc set-number number)
    (send this-desc set-label label)
    (send this-desc set-type type)
    (unless (symbol? type)
      (add-unresolved-field this-ast this-desc))]


   [(ast:oneof (name fields))
    #:scoped-name name
    ;; TODO: compile oneof options
    (for ([sub-field (in-list fields)])
      (let ([sub-field-desc (send (current-message) add-field
                                  (ast:field-name sub-field))])
        (compile-ast sub-field sub-field-desc)
        (send sub-field-desc set-parent-oneof this-desc)))]


   [(ast:enum (name vals opts))
    #:scoped-name name
    #:sub-asts vals => add-value
    ;; TODO: compile enum options
    ]

   [(ast:enum-val (name number opts))
    #:scoped-name name
    (send this-desc set-number number)
    ;; TODO: compile enum value options
    ]



   ))


;; compile the root of an ast tree into a file-descriptor%
;; this is recursive, checks for name clashes,
;; populates all-descriptors and compiles options (TODO).
;;
;; this also resolves all types, so it assumes that all
;; required types will be introduced after a first pass
;; through the tree. the best way to assure this is to
;; use the ordering produced by dependencies.rkt
;;
;; compile-root : ast:root? -> file-descriptor%
(define (compile-root ast)
  (match ast
    [(struct ast:root (loc pkg imports messages enums opts))
     ;; TODO: dependencies set
     (define file-desc (new file-descriptor%
                            [file-path (ast-source ast)]
                            [package pkg]))

     (hash-set! (file-descriptor-pool)
                (ast-source ast)
                file-desc)

     ;; register subscope variants of the package name
     ;; e.g. "foo.bar.baz" => "foo.bar.baz", "foo.bar", "foo"
     (for ([ss (in-list (subscopes pkg))])
       (hash-ref! (all-descriptors) ss file-desc))

     (define unresolved
       (parameterize ([current-file-descriptor file-desc]
                      [current-scope pkg]
                      [current-message #f]
                      [current-unresolved '()])

         ;; TODO: compile file options

         (for ([msg-ast (in-list messages)])
           (compile-ast msg-ast
                        (send file-desc add-message
                              (ast:message-name msg-ast))))

         (for ([enum-ast (in-list enums)])
           (compile-ast enum-ast
                        (send file-desc add-enum
                              (ast:enum-name enum-ast))))

         (current-unresolved)))

     ;; TODO: resolve types

     file-desc]))




;; reset all parameters to ensure fresh compilation
(define-syntax-rule (with-clean-compile body ...)
  (parameterize ([file-descriptor-pool (make-hash)]
                 [all-descriptors (make-hash)]
                 [current-scope ""]
                 [current-message #f]
                 [current-unresolved '()]
                 [current-file-descriptor #f])
    body ...))
